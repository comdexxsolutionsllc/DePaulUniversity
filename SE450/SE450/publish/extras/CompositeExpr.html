<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head>  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">  <meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">  <title>OOP-LComposite</title>  <link rel="StyleSheet" href="/%7Elaufer/koko.css" type="text/css"></head><body><h1>The Composite Pattern</h1><h2>References</h2><p>In this material, we will explore, via an example, the Compositepattern. Let us say that we are aiming to work with arithmeticexpressions built out of +,-, *, / and constants. Thus, the expressionsthat we are interested in are described by the BNF grammar: </p><table border="0">  <tbody>    <tr>      <td>e</td>      <td>::=</td>      <td>c</td>      <td>(constant)</td>    </tr>    <tr>      <td>&nbsp;</td>      <td>|</td>      <td>e1+e2 </td>      <td>(addition)</td>    </tr>    <tr>      <td>&nbsp;</td>      <td>|</td>      <td>e1-e2</td>      <td>(minus)</td>    </tr>    <tr>      <td>&nbsp;</td>      <td>|</td>      <td>e1*e2</td>      <td>(multiplication)</td>    </tr>    <tr>      <td>&nbsp;</td>      <td>|</td>      <td>e1/e2</td>      <td>(quotient)</td>    </tr>  </tbody></table><p>The operations that we desire are as follows:</p><ul type="disc">  <li>Evaluation via an inorder traversal</li>  <li>Preorder traversal for display</li>  <li>Postorder traversal for display</li></ul><p>We begin by defining an interface that captures the desiredfunctionality:</p><pre>public interface Expr {<br>    void preorder();<br>    void postorder();<br>    int evaluate();<br>}</pre><p>Now, for each constructor of arithmetic expressions that we areinterested in, we have a subclass that implements this interface. Thebasic idea is to use dynamic binding as a replacement for conditionalsthat perform switching based on the kind of expression. Thus, we arelooking at a picture of the kind:</p><p><img src="SimpleExpressions.gif" style="width: 630px; height: 201px;" alt="Expr class hierarchy"></p><p>Let us begin by only looking at the constructors of the subclasses.The constructors reflect the arity of the arithmetic operators.  Thus,we have:</p><blockquote>  <table border="0">    <tbody>      <tr>        <td>Const(int i)</td>      </tr>      <tr>        <td>Plus(Expr lt, Expr rt)</td>      </tr>      <tr>        <td>Minus(Expr lt, Expr rt)</td>      </tr>      <tr>        <td>Mult(Expr lt, Expr rt)</td>      </tr>      <tr>        <td>Quot(Expr lt, Expr rt)</td>      </tr>    </tbody>  </table></blockquote><p>Note how the constructors as well as the class diagram show thatcertain kinds of expressions (all except <code>Const</code>) arecomposed from subexpressions.  Hence the name <em>Composite Pattern</em>.</p><p>Even before we write the code that implements these subclasses, theform of the constructors allows us to explore thre representation ofexpressions that we have achieved. </p><blockquote>  <table border="0">    <tbody>      <tr>        <td>1</td>        <td>new Const(1)</td>      </tr>      <tr>        <td>1+2</td>        <td>new Plus(new Const(1), new Const(2))</td>      </tr>      <tr>        <td>3*4</td>        <td>new Mult(new Const(3), new Const(4))</td>      </tr>      <tr>        <td>(1+2)-(3*4)</td>        <td>new Minus(new Plus(new Const(1), new Const(2)),  new Mult(new Const(3), new Const(4)))</td>      </tr>      <tr>        <td>((1+2)-(3*4))/5</td>        <td>new Quot(new Minus(new Plus(new Const(1), newConst(2)), new Mult(new Const(3), new Const(4))), new            Const(5)</td>      </tr>    </tbody>  </table></blockquote><p>What we are doing is write down the prefix form of the expressiontree. The key is that all the above expressions are of type Expr,enabling the following code to typecheck.</p><blockquote>  <pre>Expr one = new Const(1);<br>Expr onePtwo = new Plus(new Const(1), new Const(2));<br>Expr threeMfour = new Mult(new Const(3), new Const(4));<br>Expr m = new Minus(onePtwo, threeMfour);<br>Expr n = new Quot(m,new Const(5));</pre></blockquote><p>Before we proceed further, let us consider each of the subclasses inturn.</p><pre>class Const implements Expr {<br>    private int v;<br><br>    public Const(int w) { v = w;}<br><br>    public int evaluate() { return v; }<br>    public void preorder() { System.out.println("CONST" + v); }<br>    public void postorder() { System.out.println("CONST" + v); }<br>}</pre><pre>class Plus implements Expr {<br>    Expr lt, rt;<br><br>    public Plus(Expr l, Expr r) { lt = l; rt =r ; }<br><br>    public int evaluate() { return lt.evaluate() + rt.evaluate();}<br><br>    public void preorder() {<br>        System.out.println("PLUS");<br>        lt.preorder();<br>        rt.preorder();<br>    }<br><br>    public void postorder() {<br>        lt.postorder();<br>        rt.postorder();<font face="Times New Roman"></font>        System.out.println("PLUS");<br>    }<br>}</pre><pre>class Minus implements Expr {<br>    Expr lt, rt;<br><br>    public Minus(Expr l, Expr r) { lt = l; rt =r ; }<br><br>    public int evaluate() { return lt.evaluate() - rt.evaluate(); }<br><br>    public void preorder() {<br>        System.out.println("MINUS");<br>        lt.preorder();<br>        rt.preorder();<br>    }<br><br>    public void postorder() {<br>        lt.postorder();<br>        rt.postorder();<br>        System.out.println("MINUS");<br>    }<br>}</pre><pre>class Mult implements Expr {<br>    Expr lt, rt;<br><br>    public Mult(Expr l, Expr r) { lt = l; rt =r ; }<br><br>    public int evaluate() { return lt.evaluate() *rt.evaluate();}<br><br>    public void preorder() {<br>        System.out.println("MULT");<br>        lt.preorder();<br>        rt.preorder();<br>    }<br><br>    public void postorder() {<br>        lt.postorder();<br>        rt.postorder();<br>        System.out.println("MULT");<br>    }<br>}</pre><pre>class Quot implements Expr {<br>    Expr lt, rt;<br><br>    public Quot(Expr l, Expr r) { lt = l; rt =r ; }<br><br>    public int evaluate() { return lt.evaluate() / rt.evaluate();}<br><br>    public void preorder() {<br>        System.out.println("QUOT");<br>        lt.preorder();<br>        rt.preorder();<br>    }<br><br>    public void postorder() {<br>        lt.postorder();<br>        rt.postorder();<br>        System.out.println("QUOT");<br>    }<br>}</pre><p>The striking feature of the above code is the total absence ofconditionals. Indeed, a main theme of the lectures will be "Inheritanceis a succinct way to express conditionals". To make this discussionconcrete, considera typical recursive evaluation function that would bewritten in a standard imperative language, where we have a record typecalled Node, with a Type function that yields the type of node. Theevaluation makes a case-switch based on the type.</p><blockquote>  <pre>public int evaluate(Node n) {<br>    int r;<br>    if (Type(Node) == CONSTANT) {<br>        r = n.contents();<br>    } else if (Type(Node) == PLUS) {<br>        r = evaluate(n.left) + evaluate(n.right);<br>    }<br>    ...<br>}</pre></blockquote><p>In our presentation, the effect of the conditional is achieved bydynamic dispatch. For example, consider the following code. </p><blockquote>  <pre>Expr one = new Const(1);<br>Expr onePtwo = new Plus(new Const(1), new Const(2));<br>Expr threeMfour = new Mult(new Const(3), new Const(4));<br>Expr m = new Minus(onePtwo, threeMfour);<br>Expr n = new Quot(m,new Const(5));<br>System.out.println(n.evaluate());</pre></blockquote><p>We will trace the execution a little to see the way in which dynamicdispatch works. </p><ul type="disc">  <li>n.evaluate() --- n is an object of Class Quot, so the        evaluate method invoked is that of Class Quot. This call        invokes evaluate on m and new Const(5). Note that the         code ofclass Quot (indeed of all subclasses) is not         aware of the typeof nodes of its two components. </li>  <li>new Const(5).evaluate() --- new Const(5) is an object ofclass Const. Thus, the evaluate method invoked is of the        subclass Const and this call returns the value 5.</li>  <li>m.evaluate() --- m is an object of class Minus. Thus, theevaluate method invokes in of the subclass Minus.</li></ul><h2>Issues to explore and think about</h2><ul type="disc">  <li>The presentation above is very fragile with respect to        the addition of new operations at the parent class. Thus,         anysuch change has to be carried out systematically         across allsubclasses. In future lectures, we will         examine the use ofanother design pattern, the Visitor,         to localize such changes.</li>  <li>Those familiar with recursive data structures and patternmatching constructs in languages such as ML, will         recognize theComposite pattern as a way to describe         recursive datastructures. The Visitor pattern will         enable us to build patternmatching in the context of the         OO paradigm. </li>  <li>In the presentation above, there was no need for parent        pointers. In general applications of the Composite         pattern,maintaining references from children to parents         can facilitatethe traversal of the data strucuture ---         for a more detailedtreatment, see page 166 of Gamma et         al.</li>  <li>The primary aim of the Composite pattern is to insulate        clients from the different kinds of components. in our         example,the clients are only aware of Expr, and are         insulated from allthe different ways of building         arithmetic expressions. There issome tension between         this aim and the possible variety of nodetypes. For         example, in our example, the Constant nodes differfrom         others in that they are base case; in all other cases,    they form inductive steps of expression building, and         buildbigger expressions out of smaller ones. Thus, in         all theselatter cases, they need data strcuctures to store andmanipulate references to children. In our         example, thesemanipulations are localized to such nodes         and are not expressedin the Expr interface. In general,         this may not be possible.For a detailed discussion,         refer to pages 167--170 of Gamma etal.</li>  <li>The use of the Composite pattern to define a language is calledthe <a href="http://home.earthlink.net/%7Ehuston2/dp/interpreter.html">Interpreterpattern</a>.</li></ul></body></html>